{"status":"ok","feed":{"url":"https://medium.com/feed/@s.lyapustin","title":"Stories by Sergey Lyapustin on Medium","link":"https://medium.com/@s.lyapustin?source=rss-4a1cf606d753------2","author":"","description":"Stories by Sergey Lyapustin on Medium","image":"https://cdn-images-1.medium.com/fit/c/150/150/1*BUzM4u-Ljd7SSeTfGAmTtg.jpeg"},"items":[{"title":"How I Build My Own Amazon S3 Storage","pubDate":"2019-08-05 15:33:14","link":"https://itnext.io/how-i-build-my-own-amazon-s3-storage-5de56b4c6612?source=rss-4a1cf606d753------2","guid":"https://medium.com/p/5de56b4c6612","author":"Sergey Lyapustin","thumbnail":"https://cdn-images-1.medium.com/max/1098/1*xqQSNl-ig29l9PECdQ5ahg.jpeg","description":"<div class=\"medium-feed-item\">\n<p class=\"medium-feed-image\"><a href=\"https://itnext.io/how-i-build-my-own-amazon-s3-storage-5de56b4c6612?source=rss-4a1cf606d753------2\"><img src=\"https://cdn-images-1.medium.com/max/1098/1*xqQSNl-ig29l9PECdQ5ahg.jpeg\" width=\"1098\"></a></p>\n<p class=\"medium-feed-snippet\">Recently I decided to move my side projects to Heroku. But Heroku does not provide a way to host media files. You need to use external\u2026</p>\n<p class=\"medium-feed-link\"><a href=\"https://itnext.io/how-i-build-my-own-amazon-s3-storage-5de56b4c6612?source=rss-4a1cf606d753------2\">Continue reading on ITNEXT \u00bb</a></p>\n</div>","content":"<div class=\"medium-feed-item\">\n<p class=\"medium-feed-image\"><a href=\"https://itnext.io/how-i-build-my-own-amazon-s3-storage-5de56b4c6612?source=rss-4a1cf606d753------2\"><img src=\"https://cdn-images-1.medium.com/max/1098/1*xqQSNl-ig29l9PECdQ5ahg.jpeg\" width=\"1098\"></a></p>\n<p class=\"medium-feed-snippet\">Recently I decided to move my side projects to Heroku. But Heroku does not provide a way to host media files. You need to use external\u2026</p>\n<p class=\"medium-feed-link\"><a href=\"https://itnext.io/how-i-build-my-own-amazon-s3-storage-5de56b4c6612?source=rss-4a1cf606d753------2\">Continue reading on ITNEXT \u00bb</a></p>\n</div>","enclosure":{},"categories":["amazon-s3","python","django","heroku"]},{"title":"Heroku Chatbot with Celery, WebSockets, and Redis.","pubDate":"2019-07-09 10:43:06","link":"https://itnext.io/heroku-chatbot-with-celery-websockets-and-redis-340fcd160f06?source=rss-4a1cf606d753------2","guid":"https://medium.com/p/340fcd160f06","author":"Sergey Lyapustin","thumbnail":"https://cdn-images-1.medium.com/max/640/1*O3oDCtp5Db-Z6tZqxfGSCw.jpeg","description":"\n<h3>Django Chatbot with Celery, WebSockets, and\u00a0Redis.</h3>\n<p>Let\u2019s create a Chatbot which can execute tasks asynchronously using Celery and communicate via WebSockets.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/640/1*O3oDCtp5Db-Z6tZqxfGSCw.jpeg\"><figcaption>Chatbot robot by <a href=\"https://www.flickr.com/photos/beantin/\">James Royal-Lawson</a></figcaption></figure><h4>TL;DR.</h4>\n<p>Here a <a href=\"https://github.com/slyapustin/django-chatbot\">Github repo</a>, just click <a href=\"https://heroku.com/deploy?template=https://github.com/inoks/django-chatbot\">Deploy to\u00a0Heroku</a>.</p>\n<h3>Django</h3>\n<p>We will use Django as a base for our application:</p>\n<ul>\n<li>HTTP requests\u00a0handler</li>\n<li>App configuration</li>\n<li>Template engine</li>\n</ul>\n<h3>Redis</h3>\n<p>We need to use Redis in a couple of\u00a0places:</p>\n<ul>\n<li>Cache Storage</li>\n<li>Celery Message Broker and Result\u00a0Backend</li>\n<li>Channel layer for the WebSocket communication</li>\n</ul>\n<p>We will use Heroku for deployment, so we don\u2019t need to install and configure Redis manually. Redis DSN will be available as an environment variable REDIS_URL so we can use it everywhere we need\u00a0it.</p>\n<h4>Redis as a Cache\u00a0Storage</h4>\n<p>Django does not support Redis internally, so we need to use the extra package. We are going to use<a href=\"https://github.com/niwinz/django-redis\">django-redis</a>. It\u2019s full-featured Redis cache backend for\u00a0Django.</p>\n<pre>pip install django-redis</pre>\n<p>This will install a couple more dependencies, including <a href=\"https://github.com/andymccurdy/redis-py\">redis-p</a>y\u200a\u2014\u200aPython interface to the\u00a0Redis.</p>\n<p>We only need to update our Django project configuration with the CACHES settings.</p>\n<a href=\"https://medium.com/media/5b3aa370bd2f3e71a56c122ea7222746/href\">https://medium.com/media/5b3aa370bd2f3e71a56c122ea7222746/href</a><h4>Celery with Redis as a Message\u00a0Broker</h4>\n<p>We will have some tasks which may take a while. For example, getting a response from the remote server. So we need to do them in the background and send the result back to the client when it will be available.</p>\n<p>Configuration for Celery is pretty simple, we are going to reuse our REDIS_URL for the CeleryBROKER_URL and RESULT_BACKEND.</p>\n<a href=\"https://medium.com/media/ef9f87ee79292e13f9309de034c307e3/href\">https://medium.com/media/ef9f87ee79292e13f9309de034c307e3/href</a><p>Let\u2019s define our Celery instance inside project/celery.py:</p>\n<a href=\"https://medium.com/media/4b04dce2522daf162135aab2951a6bfb/href\">https://medium.com/media/4b04dce2522daf162135aab2951a6bfb/href</a><p>And we need to import Celery instance in our project, to ensure the app is loaded when Django\u00a0starts.</p>\n<a href=\"https://medium.com/media/6db14fcbc7595adfc1f75408b4e6dba2/href\">https://medium.com/media/6db14fcbc7595adfc1f75408b4e6dba2/href</a><p>So now our Celery is ready and we can add background tasks to our project. For example this\u00a0one:</p>\n<a href=\"https://medium.com/media/4dbe8d2fa21d13ffe0bb098271adee25/href\">https://medium.com/media/4dbe8d2fa21d13ffe0bb098271adee25/href</a><h3>WebSockets with Django\u00a0Channels</h3>\n<p>We want to send a result from to the client immediately as it is available. Without querying it every couple of seconds via scheduled AJAX\u00a0calls.</p>\n<p><strong>WebSocket</strong> is a computer communications protocol, providing full-duplex communication channels over a single TCP connection. So user can send data to the backend and backend can send data to the\u00a0user.</p>\n<p><a href=\"https://github.com/django/channels\">Django Channels</a> are the way to go if you need to have WebSockets. There two versions available now 1.x and 2.x. They have major changes and upgrade from 1.x to 2.x can be a big project if you have a fairly big application. Version 1.x is no longer supported, so for new projects, you should use the 2.x\u00a0branch.</p>\n<p>Django-Channels has really good <a href=\"https://channels.readthedocs.io/en/latest/\">documentation</a> available on the official website, so I encourage you to\u00a0check.</p>\n<p>Key moments are\u200a\u2014\u200awe need to change couple of things in our application to support WebSockets.</p>\n<h4>Daphne</h4>\n<p>In order to use WebSockets we need to have a web server, which supports it. So we need to replace <a href=\"https://docs.djangoproject.com/en/2.2/howto/deployment/wsgi/gunicorn/\">Gunicorn</a> which we usually use to serve Django-powered websites with the\u00a0<a href=\"https://github.com/django/daphne\">Daphne</a>.</p>\n<p>Daphne is an HTTP, HTTP2 and WebSocket protocol server for <a href=\"https://github.com/django/asgiref/blob/master/specs/asgi.rst\">ASGI</a> and <a href=\"https://github.com/django/asgiref/blob/master/specs/www.rst\">ASGI-HTTP</a>, developed to power Django Channels.</p>\n<p>There is nothing to configure for our application, we can just run it the same way as we run WSGI application, but instead of WSGI we need to point it to the ASGI application:</p>\n<pre>daphne project.asgi:application</pre>\n<p>ASGI configuration looks the same as WSGI but points to the Django Channels application instead:</p>\n<a href=\"https://medium.com/media/361629056ef403aae25fabdbd37c738c/href\">https://medium.com/media/361629056ef403aae25fabdbd37c738c/href</a><h4>Django-Channels and\u00a0Redis</h4>\n<p>Django channels are some kind of communication system, which allow multiple consumer instances to talk with each other, and with other parts of\u00a0Django.</p>\n<p>A channel layer provides the following abstractions:</p>\n<ul>\n<li>A <strong>channel</strong> is a mailbox there messages can be sent to. Each channel has a name. Anyone who has the name of a channel can send a message to the\u00a0channel.</li>\n<li>A <strong>group</strong> is a group of related channels. A group has a name. Anyone who has the name of a group can add/remove a channel to the group by name and send a message to all channels in the\u00a0group.</li>\n</ul>\n<p>Every consumer instance has an automatically generated unique channel name, and so can be communicated via a channel\u00a0layer.</p>\n<p>So let\u2019s define CHANNEL_LAYERS for that project. We are going to use <a href=\"https://github.com/django/channels_redis/\">channels_redis</a> for that. So we need to define the backend and provide Redis\u00a0DSN:</p>\n<a href=\"https://medium.com/media/592a10d02b9608d6ae412590e23a71bf/href\">https://medium.com/media/592a10d02b9608d6ae412590e23a71bf/href</a><h4>WebSocket Consumers and\u00a0Routing</h4>\n<p>Now we need to define how we will interact with our clients\u200a\u2014\u200afrontend JS calls. So we will receive every message (as a JSON string) from the client and do something with\u00a0it.</p>\n<p>Here is how it may\u00a0look:</p>\n<a href=\"https://medium.com/media/9af120b85d3852104ca48437201f53d3/href\">https://medium.com/media/9af120b85d3852104ca48437201f53d3/href</a><p>And as our application can have multiple consumers (same way as we may have multiple Django views) we need to have URL routing similar to the Django urls.py\u00a0file:</p>\n<a href=\"https://medium.com/media/34fb035775755ca0c5b25abb8ad4ddfa/href\">https://medium.com/media/34fb035775755ca0c5b25abb8ad4ddfa/href</a><p>So when the client sent a message to the WebSocket /ws/chat/ path\u200a\u2014\u200ait will be processed by our ChatConsumer.</p>\n<p>And finally, we need to include our application URLs to the main router\u200a\u2014\u200aproject/routing.py:</p>\n<pre># project/routing.py<br>from channels.routing import ProtocolTypeRouter, URLRouter<br>import chat.routing </pre>\n<pre>application = ProtocolTypeRouter({    <br>    # (http-&gt;Django views is added by default)    <br>    'websocket':    <br>        URLRouter(<br>            chat.routing.websocket_urlpatterns<br>        ),<br>})</pre>\n<p>And point to it from our project/settings.py file:</p>\n<pre>ASGI_APPLICATION = \"project.routing.application\"</pre>\n<h3>Deployment to\u00a0Heroku</h3>\n<p>I will use Heroku for deployment as it\u2019s the quickest way to deploy everything in one step. And also\u200a\u2014\u200ait\u2019s free (they required an account verification though).</p>\n<h4>Procfile</h4>\n<p>That file contains processes types definition:</p>\n<a href=\"https://medium.com/media/1f5e56987f2975fa5267dd56ecb319b7/href\">https://medium.com/media/1f5e56987f2975fa5267dd56ecb319b7/href</a><p>Here we define what we need to do during the application release phase and configure two application instances:</p>\n<ul>\n<li>web\u200a\u2014\u200aDaphne server which will listen on $PORT and handle our https:// and wss:// requests.</li>\n<li>worker\u200a\u2014\u200aCelery worker instance to process our asynchronous task\u00a0queue.</li>\n</ul>\n<h4>Heroku app.json\u00a0manifest</h4>\n<p>This is the file that will be used to create a new Heroku website instance from\u00a0scratch.</p>\n<a href=\"https://medium.com/media/3eb5d11a609e2d621776edc658e1ccf0/href\">https://medium.com/media/3eb5d11a609e2d621776edc658e1ccf0/href</a><ul>\n<li>Environment variables we need to be set for our app (like Django SECRET_KEY value)</li>\n<li>Which services do we need to have (PostgreSQL, Redis)</li>\n<li>Which type of the virtual machine do we want to have heroku/python.</li>\n</ul>\n<p>That file can also be used to create a nice Deploy to Heroku button. So it can be deployed in one click next\u00a0time.</p>\n<figure><a href=\"https://heroku.com/deploy?template=https://github.com/inoks/django-chatbot\"><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/376/1*CYwWx7OT3d1bndflT8Bfsg.png\"></a></figure><p>This was a brief explanation without going too much into the details (which will be covered in the next articles).</p>\n<p>Project available on Github: <a href=\"https://github.com/slyapustin/django-chatbot\">https://github.com/slyapustin/django-chatbot</a></p>\n<p>Demo Chatbot: <a href=\"https://django-chat-bot.herokuapp.com/\">https://django-chat-bot.herokuapp.com/</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=340fcd160f06\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://itnext.io/heroku-chatbot-with-celery-websockets-and-redis-340fcd160f06\">Heroku Chatbot with Celery, WebSockets, and Redis.</a> was originally published in <a href=\"https://itnext.io/\">ITNEXT</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n","content":"\n<h3>Django Chatbot with Celery, WebSockets, and\u00a0Redis.</h3>\n<p>Let\u2019s create a Chatbot which can execute tasks asynchronously using Celery and communicate via WebSockets.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/640/1*O3oDCtp5Db-Z6tZqxfGSCw.jpeg\"><figcaption>Chatbot robot by <a href=\"https://www.flickr.com/photos/beantin/\">James Royal-Lawson</a></figcaption></figure><h4>TL;DR.</h4>\n<p>Here a <a href=\"https://github.com/slyapustin/django-chatbot\">Github repo</a>, just click <a href=\"https://heroku.com/deploy?template=https://github.com/inoks/django-chatbot\">Deploy to\u00a0Heroku</a>.</p>\n<h3>Django</h3>\n<p>We will use Django as a base for our application:</p>\n<ul>\n<li>HTTP requests\u00a0handler</li>\n<li>App configuration</li>\n<li>Template engine</li>\n</ul>\n<h3>Redis</h3>\n<p>We need to use Redis in a couple of\u00a0places:</p>\n<ul>\n<li>Cache Storage</li>\n<li>Celery Message Broker and Result\u00a0Backend</li>\n<li>Channel layer for the WebSocket communication</li>\n</ul>\n<p>We will use Heroku for deployment, so we don\u2019t need to install and configure Redis manually. Redis DSN will be available as an environment variable REDIS_URL so we can use it everywhere we need\u00a0it.</p>\n<h4>Redis as a Cache\u00a0Storage</h4>\n<p>Django does not support Redis internally, so we need to use the extra package. We are going to use<a href=\"https://github.com/niwinz/django-redis\">django-redis</a>. It\u2019s full-featured Redis cache backend for\u00a0Django.</p>\n<pre>pip install django-redis</pre>\n<p>This will install a couple more dependencies, including <a href=\"https://github.com/andymccurdy/redis-py\">redis-p</a>y\u200a\u2014\u200aPython interface to the\u00a0Redis.</p>\n<p>We only need to update our Django project configuration with the CACHES settings.</p>\n<a href=\"https://medium.com/media/5b3aa370bd2f3e71a56c122ea7222746/href\">https://medium.com/media/5b3aa370bd2f3e71a56c122ea7222746/href</a><h4>Celery with Redis as a Message\u00a0Broker</h4>\n<p>We will have some tasks which may take a while. For example, getting a response from the remote server. So we need to do them in the background and send the result back to the client when it will be available.</p>\n<p>Configuration for Celery is pretty simple, we are going to reuse our REDIS_URL for the CeleryBROKER_URL and RESULT_BACKEND.</p>\n<a href=\"https://medium.com/media/ef9f87ee79292e13f9309de034c307e3/href\">https://medium.com/media/ef9f87ee79292e13f9309de034c307e3/href</a><p>Let\u2019s define our Celery instance inside project/celery.py:</p>\n<a href=\"https://medium.com/media/4b04dce2522daf162135aab2951a6bfb/href\">https://medium.com/media/4b04dce2522daf162135aab2951a6bfb/href</a><p>And we need to import Celery instance in our project, to ensure the app is loaded when Django\u00a0starts.</p>\n<a href=\"https://medium.com/media/6db14fcbc7595adfc1f75408b4e6dba2/href\">https://medium.com/media/6db14fcbc7595adfc1f75408b4e6dba2/href</a><p>So now our Celery is ready and we can add background tasks to our project. For example this\u00a0one:</p>\n<a href=\"https://medium.com/media/4dbe8d2fa21d13ffe0bb098271adee25/href\">https://medium.com/media/4dbe8d2fa21d13ffe0bb098271adee25/href</a><h3>WebSockets with Django\u00a0Channels</h3>\n<p>We want to send a result from to the client immediately as it is available. Without querying it every couple of seconds via scheduled AJAX\u00a0calls.</p>\n<p><strong>WebSocket</strong> is a computer communications protocol, providing full-duplex communication channels over a single TCP connection. So user can send data to the backend and backend can send data to the\u00a0user.</p>\n<p><a href=\"https://github.com/django/channels\">Django Channels</a> are the way to go if you need to have WebSockets. There two versions available now 1.x and 2.x. They have major changes and upgrade from 1.x to 2.x can be a big project if you have a fairly big application. Version 1.x is no longer supported, so for new projects, you should use the 2.x\u00a0branch.</p>\n<p>Django-Channels has really good <a href=\"https://channels.readthedocs.io/en/latest/\">documentation</a> available on the official website, so I encourage you to\u00a0check.</p>\n<p>Key moments are\u200a\u2014\u200awe need to change couple of things in our application to support WebSockets.</p>\n<h4>Daphne</h4>\n<p>In order to use WebSockets we need to have a web server, which supports it. So we need to replace <a href=\"https://docs.djangoproject.com/en/2.2/howto/deployment/wsgi/gunicorn/\">Gunicorn</a> which we usually use to serve Django-powered websites with the\u00a0<a href=\"https://github.com/django/daphne\">Daphne</a>.</p>\n<p>Daphne is an HTTP, HTTP2 and WebSocket protocol server for <a href=\"https://github.com/django/asgiref/blob/master/specs/asgi.rst\">ASGI</a> and <a href=\"https://github.com/django/asgiref/blob/master/specs/www.rst\">ASGI-HTTP</a>, developed to power Django Channels.</p>\n<p>There is nothing to configure for our application, we can just run it the same way as we run WSGI application, but instead of WSGI we need to point it to the ASGI application:</p>\n<pre>daphne project.asgi:application</pre>\n<p>ASGI configuration looks the same as WSGI but points to the Django Channels application instead:</p>\n<a href=\"https://medium.com/media/361629056ef403aae25fabdbd37c738c/href\">https://medium.com/media/361629056ef403aae25fabdbd37c738c/href</a><h4>Django-Channels and\u00a0Redis</h4>\n<p>Django channels are some kind of communication system, which allow multiple consumer instances to talk with each other, and with other parts of\u00a0Django.</p>\n<p>A channel layer provides the following abstractions:</p>\n<ul>\n<li>A <strong>channel</strong> is a mailbox there messages can be sent to. Each channel has a name. Anyone who has the name of a channel can send a message to the\u00a0channel.</li>\n<li>A <strong>group</strong> is a group of related channels. A group has a name. Anyone who has the name of a group can add/remove a channel to the group by name and send a message to all channels in the\u00a0group.</li>\n</ul>\n<p>Every consumer instance has an automatically generated unique channel name, and so can be communicated via a channel\u00a0layer.</p>\n<p>So let\u2019s define CHANNEL_LAYERS for that project. We are going to use <a href=\"https://github.com/django/channels_redis/\">channels_redis</a> for that. So we need to define the backend and provide Redis\u00a0DSN:</p>\n<a href=\"https://medium.com/media/592a10d02b9608d6ae412590e23a71bf/href\">https://medium.com/media/592a10d02b9608d6ae412590e23a71bf/href</a><h4>WebSocket Consumers and\u00a0Routing</h4>\n<p>Now we need to define how we will interact with our clients\u200a\u2014\u200afrontend JS calls. So we will receive every message (as a JSON string) from the client and do something with\u00a0it.</p>\n<p>Here is how it may\u00a0look:</p>\n<a href=\"https://medium.com/media/9af120b85d3852104ca48437201f53d3/href\">https://medium.com/media/9af120b85d3852104ca48437201f53d3/href</a><p>And as our application can have multiple consumers (same way as we may have multiple Django views) we need to have URL routing similar to the Django urls.py\u00a0file:</p>\n<a href=\"https://medium.com/media/34fb035775755ca0c5b25abb8ad4ddfa/href\">https://medium.com/media/34fb035775755ca0c5b25abb8ad4ddfa/href</a><p>So when the client sent a message to the WebSocket /ws/chat/ path\u200a\u2014\u200ait will be processed by our ChatConsumer.</p>\n<p>And finally, we need to include our application URLs to the main router\u200a\u2014\u200aproject/routing.py:</p>\n<pre># project/routing.py<br>from channels.routing import ProtocolTypeRouter, URLRouter<br>import chat.routing </pre>\n<pre>application = ProtocolTypeRouter({    <br>    # (http-&gt;Django views is added by default)    <br>    'websocket':    <br>        URLRouter(<br>            chat.routing.websocket_urlpatterns<br>        ),<br>})</pre>\n<p>And point to it from our project/settings.py file:</p>\n<pre>ASGI_APPLICATION = \"project.routing.application\"</pre>\n<h3>Deployment to\u00a0Heroku</h3>\n<p>I will use Heroku for deployment as it\u2019s the quickest way to deploy everything in one step. And also\u200a\u2014\u200ait\u2019s free (they required an account verification though).</p>\n<h4>Procfile</h4>\n<p>That file contains processes types definition:</p>\n<a href=\"https://medium.com/media/1f5e56987f2975fa5267dd56ecb319b7/href\">https://medium.com/media/1f5e56987f2975fa5267dd56ecb319b7/href</a><p>Here we define what we need to do during the application release phase and configure two application instances:</p>\n<ul>\n<li>web\u200a\u2014\u200aDaphne server which will listen on $PORT and handle our https:// and wss:// requests.</li>\n<li>worker\u200a\u2014\u200aCelery worker instance to process our asynchronous task\u00a0queue.</li>\n</ul>\n<h4>Heroku app.json\u00a0manifest</h4>\n<p>This is the file that will be used to create a new Heroku website instance from\u00a0scratch.</p>\n<a href=\"https://medium.com/media/3eb5d11a609e2d621776edc658e1ccf0/href\">https://medium.com/media/3eb5d11a609e2d621776edc658e1ccf0/href</a><ul>\n<li>Environment variables we need to be set for our app (like Django SECRET_KEY value)</li>\n<li>Which services do we need to have (PostgreSQL, Redis)</li>\n<li>Which type of the virtual machine do we want to have heroku/python.</li>\n</ul>\n<p>That file can also be used to create a nice Deploy to Heroku button. So it can be deployed in one click next\u00a0time.</p>\n<figure><a href=\"https://heroku.com/deploy?template=https://github.com/inoks/django-chatbot\"><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/376/1*CYwWx7OT3d1bndflT8Bfsg.png\"></a></figure><p>This was a brief explanation without going too much into the details (which will be covered in the next articles).</p>\n<p>Project available on Github: <a href=\"https://github.com/slyapustin/django-chatbot\">https://github.com/slyapustin/django-chatbot</a></p>\n<p>Demo Chatbot: <a href=\"https://django-chat-bot.herokuapp.com/\">https://django-chat-bot.herokuapp.com/</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=340fcd160f06\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://itnext.io/heroku-chatbot-with-celery-websockets-and-redis-340fcd160f06\">Heroku Chatbot with Celery, WebSockets, and Redis.</a> was originally published in <a href=\"https://itnext.io/\">ITNEXT</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n","enclosure":{},"categories":["celery","django","redis","django-channels","heroku"]},{"title":"Elasticsearch Autocomplete for Django","pubDate":"2019-02-15 13:40:29","link":"https://itnext.io/elasticsearch-autocomplete-for-django-9dffef1d3afb?source=rss-4a1cf606d753------2","guid":"https://medium.com/p/9dffef1d3afb","author":"Sergey Lyapustin","thumbnail":"https://cdn-images-1.medium.com/max/803/1*209COHJ1LFfInRPuWQFylQ.png","description":"\n<p>So you know what Elasticsearch is and wonder, how you can improve your website search with\u00a0it?</p>\n<p>Let update our search from the <a href=\"https://medium.com/@s.lyapustin/django-polls-app-with-elasticsearch-ffc02b9e79d9\">previous article</a> to have an autocomplete feature.</p>\n<h3>What is Autocomplete?</h3>\n<p>Autocomplete is the nice to have feature for your search forms, which allow you to guide a user with suggestions while he tries to write search query on your\u00a0website.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/803/1*209COHJ1LFfInRPuWQFylQ.png\"></figure><h3>N-Grams</h3>\n<p>In order to use autocomplete we will send user input to our backend as they type it in the input field. That input usually includes phrases in the various combinations.</p>\n<p>For the best possible result here we need to use <a href=\"https://medium.com/programming-tid-bits/weekend-hacks-n-grams-f4398fc9d554\"><em>n-grams</em></a><em> </em>to<em> </em>generate effective indexes on words combinations in the original\u00a0texts.</p>\n<p>We will create an extra <strong>EdgeNgramField</strong> field on the search index to store that data based on the Question <strong>question_text</strong> field:</p>\n<pre><strong>class </strong>QuestionIndex(indexes.SearchIndex, indexes.Indexable):<br>    ...<br>    text_auto = indexes.EdgeNgramField(model_attr=<strong>'question_text'</strong>)<br>    ...</pre>\n<p>As we have changed our index schema we need to rebuild\u00a0index:</p>\n<pre>./manage.py rebuild_index</pre>\n<p>Now we can do a query using Haystack <a href=\"https://django-haystack.readthedocs.io/en/latest/searchqueryset_api.html#autocomplete\">autocomplete()</a> method:</p>\n<pre>SearchQuerySet().autocomplete(text_auto='old')</pre>\n<p>Also, let\u2019s change Haystack settings a bit so we have any updates in our models being sent to Elasticsearch immediately as they appeared. So if you add, update or delete Questions they will send to the Elasticsearch immediately:</p>\n<pre># Update Search index in realtime (using models.db.signals)<br>HAYSTACK_SIGNAL_PROCESSOR = <strong>'haystack.signals.RealtimeSignalProcessor'</strong></pre>\n<p>That is basically all we need to do on the Elasticsearch/Haystack side.</p>\n<h3>Autocomplete View</h3>\n<p>In order to handle autocomplete requests lets create an endpoint /autocomplete?q=&lt;&gt;`, which will respond with the JSON list of the questions matched user\u00a0input.</p>\n<p>So if user type query elastic djan it will respond with the JSON list of the appropriate questions list. For\u00a0ex.:</p>\n<pre>{<br>  \"results\": <br>    [<br>      \"Django Elasticsearch\",<br>      \"Poll App with Elastcisearch and Django\"<br>]</pre>\n<p>The view is pretty simple, it takes q GET query, makes an autocomplete search and returns a string representation of the 5 most relevant questions as a JSON response:</p>\n<pre><strong>def </strong>autocomplete(request):<br>    max_items = 5<br>    q = request.GET.get(<strong>'q'</strong>)<br><strong>if </strong>q:<br>        sqs = SearchQuerySet().autocomplete(text_auto=q)<br>        results = [str(result.object) <strong>for </strong>result <strong>in </strong>sqs[:max_items]]<br><strong>else</strong>:<br>        results = []<br><br><strong>return </strong>JsonResponse({<br><strong>'results'</strong>: results<br>    })</pre>\n<p>Let\u2019s add that view to urlpatterns in the urls.py\u00a0file:</p>\n<pre>urlpatterns = [<br>    ...<br>    path(<strong>'autocomplete/'</strong>, views.autocomplete, name=<strong>'autocomplete'</strong>),<br>]</pre>\n<p>That\u2019s it on the backend\u00a0side.</p>\n<h3>Handle Autocomplete on the\u00a0Frontend</h3>\n<p>There plenty of JS helpers do that. We will reuse jQuery <a href=\"https://github.com/inoks/django-polls-elasticsearch/blob/master/app/polls/static/polls/js/autocomplete.js\">Autocomplete</a> from a Haystack\u00a0<a href=\"https://django-haystack.readthedocs.io/en/latest/autocomplete.html#example-implementation\">example</a>:</p>\n<pre>&lt;<strong>form action=\"</strong>{% <strong>url 'haystack_search' </strong>%}<strong>\" class=\"autocomplete\"</strong>&gt;<br>  &lt;<strong>label for=\"q\"</strong>&gt;Search&lt;/<strong>label</strong>&gt;<br>  &lt;<strong>input id=\"q\" name=\"q\" type=\"text\" autocomplete=\"off\"</strong>&gt;<br>  &lt;<strong>input type=\"submit\" value=\"Search!\"</strong>&gt;<br>&lt;/<strong>form</strong>&gt;<br><br><br>&lt;<strong>script src=\"https://code.jquery.com/jquery-3.3.1.min.js\"</strong>&gt;&lt;/<strong>script</strong>&gt;<br>&lt;<strong>script src=\"</strong>{% <strong>static 'polls/js/autocomplete.js' </strong>%}<strong>\"</strong>&gt;&lt;/<strong>script</strong>&gt;<br><br>&lt;<strong>script type=\"text/javascript\"</strong>&gt;<br><strong>$</strong>(<strong>function </strong>() {<br><strong><em>window</em></strong>.<strong>autocomplete </strong>= <strong>new </strong><em>Autocomplete</em>({<br><strong>form_selector</strong>: <strong>'.autocomplete'</strong>,<br><strong>url</strong>: <strong>'</strong>{% <strong>url 'polls:autocomplete' </strong>%}<strong>'<br></strong>});<br><strong><em>window</em></strong>.<strong>autocomplete</strong>.setup()<br>  });<br>&lt;/<strong>script</strong>&gt;</pre>\n<p>What we do here? We have a form with the input field which is a source for our autocomplete query.</p>\n<p>As soon as the user typed query string longer than 3 symbols we send a request to our /autocomplete endpoint in order to find something related.</p>\n<p>If we found something\u200a\u2014\u200awe will display it under the input field which can be chosen to do a search\u00a0query.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/642/1*wRYhge1uchS3DDJOHvP4dw.png\"></figure><p>That is\u00a0it.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=9dffef1d3afb\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://itnext.io/elasticsearch-autocomplete-for-django-9dffef1d3afb\">Elasticsearch Autocomplete for Django</a> was originally published in <a href=\"https://itnext.io/\">ITNEXT</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n","content":"\n<p>So you know what Elasticsearch is and wonder, how you can improve your website search with\u00a0it?</p>\n<p>Let update our search from the <a href=\"https://medium.com/@s.lyapustin/django-polls-app-with-elasticsearch-ffc02b9e79d9\">previous article</a> to have an autocomplete feature.</p>\n<h3>What is Autocomplete?</h3>\n<p>Autocomplete is the nice to have feature for your search forms, which allow you to guide a user with suggestions while he tries to write search query on your\u00a0website.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/803/1*209COHJ1LFfInRPuWQFylQ.png\"></figure><h3>N-Grams</h3>\n<p>In order to use autocomplete we will send user input to our backend as they type it in the input field. That input usually includes phrases in the various combinations.</p>\n<p>For the best possible result here we need to use <a href=\"https://medium.com/programming-tid-bits/weekend-hacks-n-grams-f4398fc9d554\"><em>n-grams</em></a><em> </em>to<em> </em>generate effective indexes on words combinations in the original\u00a0texts.</p>\n<p>We will create an extra <strong>EdgeNgramField</strong> field on the search index to store that data based on the Question <strong>question_text</strong> field:</p>\n<pre><strong>class </strong>QuestionIndex(indexes.SearchIndex, indexes.Indexable):<br>    ...<br>    text_auto = indexes.EdgeNgramField(model_attr=<strong>'question_text'</strong>)<br>    ...</pre>\n<p>As we have changed our index schema we need to rebuild\u00a0index:</p>\n<pre>./manage.py rebuild_index</pre>\n<p>Now we can do a query using Haystack <a href=\"https://django-haystack.readthedocs.io/en/latest/searchqueryset_api.html#autocomplete\">autocomplete()</a> method:</p>\n<pre>SearchQuerySet().autocomplete(text_auto='old')</pre>\n<p>Also, let\u2019s change Haystack settings a bit so we have any updates in our models being sent to Elasticsearch immediately as they appeared. So if you add, update or delete Questions they will send to the Elasticsearch immediately:</p>\n<pre># Update Search index in realtime (using models.db.signals)<br>HAYSTACK_SIGNAL_PROCESSOR = <strong>'haystack.signals.RealtimeSignalProcessor'</strong></pre>\n<p>That is basically all we need to do on the Elasticsearch/Haystack side.</p>\n<h3>Autocomplete View</h3>\n<p>In order to handle autocomplete requests lets create an endpoint /autocomplete?q=&lt;&gt;`, which will respond with the JSON list of the questions matched user\u00a0input.</p>\n<p>So if user type query elastic djan it will respond with the JSON list of the appropriate questions list. For\u00a0ex.:</p>\n<pre>{<br>  \"results\": <br>    [<br>      \"Django Elasticsearch\",<br>      \"Poll App with Elastcisearch and Django\"<br>]</pre>\n<p>The view is pretty simple, it takes q GET query, makes an autocomplete search and returns a string representation of the 5 most relevant questions as a JSON response:</p>\n<pre><strong>def </strong>autocomplete(request):<br>    max_items = 5<br>    q = request.GET.get(<strong>'q'</strong>)<br><strong>if </strong>q:<br>        sqs = SearchQuerySet().autocomplete(text_auto=q)<br>        results = [str(result.object) <strong>for </strong>result <strong>in </strong>sqs[:max_items]]<br><strong>else</strong>:<br>        results = []<br><br><strong>return </strong>JsonResponse({<br><strong>'results'</strong>: results<br>    })</pre>\n<p>Let\u2019s add that view to urlpatterns in the urls.py\u00a0file:</p>\n<pre>urlpatterns = [<br>    ...<br>    path(<strong>'autocomplete/'</strong>, views.autocomplete, name=<strong>'autocomplete'</strong>),<br>]</pre>\n<p>That\u2019s it on the backend\u00a0side.</p>\n<h3>Handle Autocomplete on the\u00a0Frontend</h3>\n<p>There plenty of JS helpers do that. We will reuse jQuery <a href=\"https://github.com/inoks/django-polls-elasticsearch/blob/master/app/polls/static/polls/js/autocomplete.js\">Autocomplete</a> from a Haystack\u00a0<a href=\"https://django-haystack.readthedocs.io/en/latest/autocomplete.html#example-implementation\">example</a>:</p>\n<pre>&lt;<strong>form action=\"</strong>{% <strong>url 'haystack_search' </strong>%}<strong>\" class=\"autocomplete\"</strong>&gt;<br>  &lt;<strong>label for=\"q\"</strong>&gt;Search&lt;/<strong>label</strong>&gt;<br>  &lt;<strong>input id=\"q\" name=\"q\" type=\"text\" autocomplete=\"off\"</strong>&gt;<br>  &lt;<strong>input type=\"submit\" value=\"Search!\"</strong>&gt;<br>&lt;/<strong>form</strong>&gt;<br><br><br>&lt;<strong>script src=\"https://code.jquery.com/jquery-3.3.1.min.js\"</strong>&gt;&lt;/<strong>script</strong>&gt;<br>&lt;<strong>script src=\"</strong>{% <strong>static 'polls/js/autocomplete.js' </strong>%}<strong>\"</strong>&gt;&lt;/<strong>script</strong>&gt;<br><br>&lt;<strong>script type=\"text/javascript\"</strong>&gt;<br><strong>$</strong>(<strong>function </strong>() {<br><strong><em>window</em></strong>.<strong>autocomplete </strong>= <strong>new </strong><em>Autocomplete</em>({<br><strong>form_selector</strong>: <strong>'.autocomplete'</strong>,<br><strong>url</strong>: <strong>'</strong>{% <strong>url 'polls:autocomplete' </strong>%}<strong>'<br></strong>});<br><strong><em>window</em></strong>.<strong>autocomplete</strong>.setup()<br>  });<br>&lt;/<strong>script</strong>&gt;</pre>\n<p>What we do here? We have a form with the input field which is a source for our autocomplete query.</p>\n<p>As soon as the user typed query string longer than 3 symbols we send a request to our /autocomplete endpoint in order to find something related.</p>\n<p>If we found something\u200a\u2014\u200awe will display it under the input field which can be chosen to do a search\u00a0query.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/642/1*wRYhge1uchS3DDJOHvP4dw.png\"></figure><p>That is\u00a0it.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=9dffef1d3afb\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://itnext.io/elasticsearch-autocomplete-for-django-9dffef1d3afb\">Elasticsearch Autocomplete for Django</a> was originally published in <a href=\"https://itnext.io/\">ITNEXT</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n","enclosure":{},"categories":["elasticsearch","docker","javascript","django","haystack"]},{"title":"Django Polls App with Elasticsearch","pubDate":"2018-11-23 20:41:55","link":"https://medium.com/@s.lyapustin/django-polls-app-with-elasticsearch-ffc02b9e79d9?source=rss-4a1cf606d753------2","guid":"https://medium.com/p/ffc02b9e79d9","author":"Sergey Lyapustin","thumbnail":"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=ffc02b9e79d9","description":"\n<h3>Django, Docker and Elasticsearch</h3>\n<p>Let\u2019s create Django application which will utilize Elasticsearch engine what can do a lot of things like full-text search, fuzzy search, <a href=\"https://medium.com/@s.lyapustin/elasticsearch-autocomplete-for-django-9dffef1d3afb\">autocomplete</a>, spell check and\u00a0etc.</p>\n<p>If you\u2019re new to Django framework already trying to do something with it I think you know what Django has great tutorials with some real projects. One of them is a <a href=\"https://docs.djangoproject.com/en/2.1/intro/tutorial01/\">Polls application</a>.</p>\n<p>What we gonna do here is to extend that app to have nice search, powered by Elasticsearch.</p>\n<h3>Django Poll application</h3>\n<p>This application is pretty simple and it basically has two models: Question and Choice. You can copy-paste sources from <a href=\"https://docs.djangoproject.com/en/2.1/intro/tutorial01/\">Django Tutorial </a>at Django page or just clone it from my <a href=\"https://github.com/inoks/django-polls-elasticsearch\">GitHub repository</a>:</p>\n<pre>git clone <a href=\"https://github.com/inoks/django-polls-elasticsearch\">https://github.com/inoks/django-polls-elasticsearch</a><br>cd <a href=\"https://github.com/inoks/django-polls-elasticsearch\">django-polls-elasticsearch</a><br>docker-compose up</pre>\n<p>If you see some errors or you don\u2019t really understand what is going please take a look at <a href=\"https://docs.djangoproject.com/en/2.1/intro/tutorial01/\">Django Tutorial</a>.</p>\n<p>If you see your server up and running\u200a\u2014\u200ago to the admin page and add some Questions.</p>\n<h3>Elasticsearch instance</h3>\n<p>We will use Docker to run Elasticsearch. Those steps are pretty well documented on the <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html#docker\">Elasticsearch website</a>, except we need to use Elasticsearch 2.x instance since the newest versions are <a href=\"https://github.com/django-haystack/django-haystack/issues/1585\">not really supported</a> by Django-Haystack.</p>\n<p>So let\u2019s add new services section to our docker-compose.yml file:</p>\n<pre><strong>elasticsearch</strong>:<br><strong>image</strong>: launcher.gcr.io/google/elasticsearch2<br><strong>ports</strong>:<br>    - <strong>\"9200:9200\"<br></strong>- <strong>\"9300:9300\"</strong></pre>\n<p>Elasticsearch uses two ports by default: 9200 for RESTful API and 9300 for node communication (in case you run multiple instances).</p>\n<p>Let\u2019s run our Docker configuration with docker-compose up and test if everything works\u00a0well:</p>\n<pre>curl <a href=\"http://127.0.0.1:9200/_cat/health\">http://127.0.0.1:9200/_cat/health</a><br>1542963817 09:03:37 elasticsearch yellow 1 1 0 0 0 0 0 0 - 100.0%</pre>\n<p>You may have some other values in the response, but if you were able to receive some response\u200a\u2014\u200athis is a good sign that Elasticsearch works.</p>\n<h3>Connect Django with Elasticsearch</h3>\n<p>We will use <a href=\"https://github.com/django-haystack/django-haystack\">Django Haystack</a> app to do all integrations with Elasticsearch. In order to use Haystack we also need to install Elasticsearch official client for Python\u200a\u2014\u200a<a href=\"https://github.com/elastic/elasticsearch-py\">elasticsearch-py</a>. Unfortunately, Haystack <a href=\"https://github.com/django-haystack/django-haystack/issues/1585\">only supports 2.x</a> version of the client. So let\u2019s install Haystack and latest 2.x version of Elasticsearch package:</p>\n<pre>pip install django-haystack elasticsearch&gt;=2.0.0,&lt;3.0.0</pre>\n<p>Add haystack to your INSTALLED_APPS list at mysite/settings.pyfile:</p>\n<pre>INSTALLED_APPS = [<br><strong>'polls.apps.PollsConfig'</strong>,</pre>\n<pre>    <strong>'django.contrib.admin'</strong>,<br><strong>'django.contrib.auth'</strong>,<br><strong>'django.contrib.contenttypes'</strong>,<br><strong>'django.contrib.sessions'</strong>,<br><strong>'django.contrib.messages'</strong>,<br><strong>'django.contrib.staticfiles'</strong>,</pre>\n<pre>    <strong>'haystack'</strong>,<br>]</pre>\n<p>And provide basic configuration, so Haystack will know which search engine we want to use and where the server is\u00a0located:</p>\n<pre>HAYSTACK_CONNECTIONS = {<br><strong>'default'</strong>: {<br><strong>'ENGINE'</strong>: <strong>'haystack.backends.elasticsearch2_backend.Elasticsearch2SearchEngine'</strong>,<br><strong>'URL'</strong>: <strong>'http://127.0.0.1:9200/'</strong>,<br><strong>'INDEX_NAME'</strong>: <strong>'haystack'</strong>,<br>    },<br>}</pre>\n<h3>Create Search configuration</h3>\n<p>In order for our search engine to work we need to configure which data and fields we want to send to the search engine and how the search engine needs to treat them. Django-Haystack allows us to do that via SearchIndex classes.</p>\n<p>Let\u2019s create search_indexes.pyinside our polls application:</p>\n<pre><strong>class </strong>QuestionIndex(indexes.SearchIndex, indexes.Indexable):<br>    text = indexes.CharField(document=<strong>True</strong>, use_template=<strong>True</strong>)<br>    pub_date = indexes.DateTimeField(model_attr=<strong>'pub_date'</strong>)</pre>\n<pre>    <strong>def </strong>get_model(self):<br><strong>return </strong>Question</pre>\n<pre>    <strong>def </strong>index_queryset(self, using=<strong>None</strong>):<br><em>\"\"\"Used when the entire index for model is updated.\"\"\"<br></em><strong>return </strong>self.get_model().objects.filter(pub_date__lte=timezone.now())</pre>\n<p>And as we use a template for our text field, we also need to create a question_text.txt template file, which is as simple\u00a0as:</p>\n<pre>{{ object.question_text }}</pre>\n<p>That means Haystack should only index values from the fieldquestion_text\u00a0.</p>\n<h3>Adding Search page to the Polls\u00a0app</h3>\n<p>So we almost ready now to use new Elasticsearch with our app and we need to create a view, where we will utilize\u00a0it.</p>\n<p>Django-Haystack comes with a predefined view for search, so we need just add it url patterns:</p>\n<pre>urlpatterns = [<br>    path(<strong>''</strong>, include(<strong>'polls.urls'</strong>)),<br>    path(<strong>'search/'</strong>, include(<strong>'haystack.urls'</strong>)),<br>    path(<strong>'admin/'</strong>, admin.site.urls),<br>]</pre>\n<p>And create a template search/search.htmlfor it, which should contain the form and can display paginated results:</p>\n<pre>&lt;<strong>h2</strong>&gt;Search&lt;/<strong>h2</strong>&gt;</pre>\n<pre>&lt;<strong>form</strong>&gt;<br>  {{ <strong>form</strong>.<strong>as_p </strong>}}<br>  &lt;<strong>br</strong>/&gt;<br>  &lt;<strong>input type=\"submit\" value=\"Search\"</strong>&gt;<br>&lt;/<strong>form</strong>&gt;<br>&lt;ul&gt;<br>  {% <strong>for result in page</strong>.<strong>object_list </strong>%}<br>    &lt;li&gt;{{ <strong>result</strong>.<strong>object </strong>}}&lt;/li&gt;<br>  {% <strong>endfor </strong>%}<br>&lt;/ul&gt;</pre>\n<h3>Populate Elasticsearch index</h3>\n<p>Haystack comes with some tools to populate and update Elasticsearch index. For the initial index build we need to\u00a0run:</p>\n<pre>./manage.py rebuild_index</pre>\n<p>To update the index after we added or updated entries we need to\u00a0run:</p>\n<pre>./manage.py update_index</pre>\n<h3>Using search</h3>\n<p>In order to use the search, you need to visit <a href=\"http://localhost:8000/search/\">http://localhost/search/</a> page and enter a\u00a0query.</p>\n<h3>That\u2019s it!</h3>\n<p>Complete source code and Docker configuration available at\u00a0<a href=\"https://github.com/inoks/django-polls-elasticsearch\">Github</a>.</p>\n<p>In the next article, we will add <a href=\"https://medium.com/@s.lyapustin/elasticsearch-autocomplete-for-django-9dffef1d3afb\">Autocomplete</a> to the search input\u00a0field.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=ffc02b9e79d9\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<h3>Django, Docker and Elasticsearch</h3>\n<p>Let\u2019s create Django application which will utilize Elasticsearch engine what can do a lot of things like full-text search, fuzzy search, <a href=\"https://medium.com/@s.lyapustin/elasticsearch-autocomplete-for-django-9dffef1d3afb\">autocomplete</a>, spell check and\u00a0etc.</p>\n<p>If you\u2019re new to Django framework already trying to do something with it I think you know what Django has great tutorials with some real projects. One of them is a <a href=\"https://docs.djangoproject.com/en/2.1/intro/tutorial01/\">Polls application</a>.</p>\n<p>What we gonna do here is to extend that app to have nice search, powered by Elasticsearch.</p>\n<h3>Django Poll application</h3>\n<p>This application is pretty simple and it basically has two models: Question and Choice. You can copy-paste sources from <a href=\"https://docs.djangoproject.com/en/2.1/intro/tutorial01/\">Django Tutorial </a>at Django page or just clone it from my <a href=\"https://github.com/inoks/django-polls-elasticsearch\">GitHub repository</a>:</p>\n<pre>git clone <a href=\"https://github.com/inoks/django-polls-elasticsearch\">https://github.com/inoks/django-polls-elasticsearch</a><br>cd <a href=\"https://github.com/inoks/django-polls-elasticsearch\">django-polls-elasticsearch</a><br>docker-compose up</pre>\n<p>If you see some errors or you don\u2019t really understand what is going please take a look at <a href=\"https://docs.djangoproject.com/en/2.1/intro/tutorial01/\">Django Tutorial</a>.</p>\n<p>If you see your server up and running\u200a\u2014\u200ago to the admin page and add some Questions.</p>\n<h3>Elasticsearch instance</h3>\n<p>We will use Docker to run Elasticsearch. Those steps are pretty well documented on the <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docker.html#docker\">Elasticsearch website</a>, except we need to use Elasticsearch 2.x instance since the newest versions are <a href=\"https://github.com/django-haystack/django-haystack/issues/1585\">not really supported</a> by Django-Haystack.</p>\n<p>So let\u2019s add new services section to our docker-compose.yml file:</p>\n<pre><strong>elasticsearch</strong>:<br><strong>image</strong>: launcher.gcr.io/google/elasticsearch2<br><strong>ports</strong>:<br>    - <strong>\"9200:9200\"<br></strong>- <strong>\"9300:9300\"</strong></pre>\n<p>Elasticsearch uses two ports by default: 9200 for RESTful API and 9300 for node communication (in case you run multiple instances).</p>\n<p>Let\u2019s run our Docker configuration with docker-compose up and test if everything works\u00a0well:</p>\n<pre>curl <a href=\"http://127.0.0.1:9200/_cat/health\">http://127.0.0.1:9200/_cat/health</a><br>1542963817 09:03:37 elasticsearch yellow 1 1 0 0 0 0 0 0 - 100.0%</pre>\n<p>You may have some other values in the response, but if you were able to receive some response\u200a\u2014\u200athis is a good sign that Elasticsearch works.</p>\n<h3>Connect Django with Elasticsearch</h3>\n<p>We will use <a href=\"https://github.com/django-haystack/django-haystack\">Django Haystack</a> app to do all integrations with Elasticsearch. In order to use Haystack we also need to install Elasticsearch official client for Python\u200a\u2014\u200a<a href=\"https://github.com/elastic/elasticsearch-py\">elasticsearch-py</a>. Unfortunately, Haystack <a href=\"https://github.com/django-haystack/django-haystack/issues/1585\">only supports 2.x</a> version of the client. So let\u2019s install Haystack and latest 2.x version of Elasticsearch package:</p>\n<pre>pip install django-haystack elasticsearch&gt;=2.0.0,&lt;3.0.0</pre>\n<p>Add haystack to your INSTALLED_APPS list at mysite/settings.pyfile:</p>\n<pre>INSTALLED_APPS = [<br><strong>'polls.apps.PollsConfig'</strong>,</pre>\n<pre>    <strong>'django.contrib.admin'</strong>,<br><strong>'django.contrib.auth'</strong>,<br><strong>'django.contrib.contenttypes'</strong>,<br><strong>'django.contrib.sessions'</strong>,<br><strong>'django.contrib.messages'</strong>,<br><strong>'django.contrib.staticfiles'</strong>,</pre>\n<pre>    <strong>'haystack'</strong>,<br>]</pre>\n<p>And provide basic configuration, so Haystack will know which search engine we want to use and where the server is\u00a0located:</p>\n<pre>HAYSTACK_CONNECTIONS = {<br><strong>'default'</strong>: {<br><strong>'ENGINE'</strong>: <strong>'haystack.backends.elasticsearch2_backend.Elasticsearch2SearchEngine'</strong>,<br><strong>'URL'</strong>: <strong>'http://127.0.0.1:9200/'</strong>,<br><strong>'INDEX_NAME'</strong>: <strong>'haystack'</strong>,<br>    },<br>}</pre>\n<h3>Create Search configuration</h3>\n<p>In order for our search engine to work we need to configure which data and fields we want to send to the search engine and how the search engine needs to treat them. Django-Haystack allows us to do that via SearchIndex classes.</p>\n<p>Let\u2019s create search_indexes.pyinside our polls application:</p>\n<pre><strong>class </strong>QuestionIndex(indexes.SearchIndex, indexes.Indexable):<br>    text = indexes.CharField(document=<strong>True</strong>, use_template=<strong>True</strong>)<br>    pub_date = indexes.DateTimeField(model_attr=<strong>'pub_date'</strong>)</pre>\n<pre>    <strong>def </strong>get_model(self):<br><strong>return </strong>Question</pre>\n<pre>    <strong>def </strong>index_queryset(self, using=<strong>None</strong>):<br><em>\"\"\"Used when the entire index for model is updated.\"\"\"<br></em><strong>return </strong>self.get_model().objects.filter(pub_date__lte=timezone.now())</pre>\n<p>And as we use a template for our text field, we also need to create a question_text.txt template file, which is as simple\u00a0as:</p>\n<pre>{{ object.question_text }}</pre>\n<p>That means Haystack should only index values from the fieldquestion_text\u00a0.</p>\n<h3>Adding Search page to the Polls\u00a0app</h3>\n<p>So we almost ready now to use new Elasticsearch with our app and we need to create a view, where we will utilize\u00a0it.</p>\n<p>Django-Haystack comes with a predefined view for search, so we need just add it url patterns:</p>\n<pre>urlpatterns = [<br>    path(<strong>''</strong>, include(<strong>'polls.urls'</strong>)),<br>    path(<strong>'search/'</strong>, include(<strong>'haystack.urls'</strong>)),<br>    path(<strong>'admin/'</strong>, admin.site.urls),<br>]</pre>\n<p>And create a template search/search.htmlfor it, which should contain the form and can display paginated results:</p>\n<pre>&lt;<strong>h2</strong>&gt;Search&lt;/<strong>h2</strong>&gt;</pre>\n<pre>&lt;<strong>form</strong>&gt;<br>  {{ <strong>form</strong>.<strong>as_p </strong>}}<br>  &lt;<strong>br</strong>/&gt;<br>  &lt;<strong>input type=\"submit\" value=\"Search\"</strong>&gt;<br>&lt;/<strong>form</strong>&gt;<br>&lt;ul&gt;<br>  {% <strong>for result in page</strong>.<strong>object_list </strong>%}<br>    &lt;li&gt;{{ <strong>result</strong>.<strong>object </strong>}}&lt;/li&gt;<br>  {% <strong>endfor </strong>%}<br>&lt;/ul&gt;</pre>\n<h3>Populate Elasticsearch index</h3>\n<p>Haystack comes with some tools to populate and update Elasticsearch index. For the initial index build we need to\u00a0run:</p>\n<pre>./manage.py rebuild_index</pre>\n<p>To update the index after we added or updated entries we need to\u00a0run:</p>\n<pre>./manage.py update_index</pre>\n<h3>Using search</h3>\n<p>In order to use the search, you need to visit <a href=\"http://localhost:8000/search/\">http://localhost/search/</a> page and enter a\u00a0query.</p>\n<h3>That\u2019s it!</h3>\n<p>Complete source code and Docker configuration available at\u00a0<a href=\"https://github.com/inoks/django-polls-elasticsearch\">Github</a>.</p>\n<p>In the next article, we will add <a href=\"https://medium.com/@s.lyapustin/elasticsearch-autocomplete-for-django-9dffef1d3afb\">Autocomplete</a> to the search input\u00a0field.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=ffc02b9e79d9\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["elasticsearch","docker","django"]}]}